解説 Socket.IO 1.0
=====================

こんにちは。sisidovski(@44_10)と申します。普段は元気にPHPを書いています。

2014年はGoやswiftなどが話題をかっさらっているのを感じますが、js界隈も盛り上がっています。altjsで天下一を決める人達[#]_がいたり、MVCフレームワークで天下一を決める人達[#]_がいたり。
Node.js界隈も色んな意味で盛り上がっていて、common.js関連やgruntやgulpなどのビルドツール、visionmedia(expressやmocha、jadeなどの作者)の勇退[#]_など、考えれば枚挙に暇がないがありません。

その中でも忘れてはならないのが、そうSocket.IO1.0のリリースですね。2年近く待っていた方もいるのではないかと思います。

待望のリリースということで、稚拙ながら解説させていただきます。

はじめに
---------

はじめにWebSocktプロトコルやSokcet.IOに関して簡単に解説し、本題のSocket.IO1.0における変更点、新機能などの説明に入っていきます。WebSocketなんて説明不要だという方は、適宜読み飛ばしてください。


WebSocketとは
--------------

WebSocketプロトコルについてはRFC6455[Ref]_に書かれている通りですが、ちょっと説明しておきますと、サーバ・クライアント間における双方向通信用の技術規定であり、TCP上で動くプロトコルです。リクエスト・レスポンス形式に沿った従来の通信とは異なり、WebSocketは一度コネクションを張った後は必要な通信を全てそのコネクション上で行うことにより、サーバからクライアントへのプッシュ配信が可能になっています。

	The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g., using XMLHttpRequest or <iframe>s and long polling).

とRFCにもある通り、WebSocketはXHRやCommet等が持つ問題（コネクションを確立するのにHTTP通信を何度も行うことや、ロングポーリング問題）を解決しつつ、双方向通信を実現することを目標にしています。WebSocketを確立するフローとしては、以下のようになります。

#. クライアントからハンドシェイク要求を送る
#. サーバー側はその要求をHTTPとして解釈し、WebSocketへと切り替えて応答を返す(Upgrade)
#. コネクションが確立する


[#] http://connpass.com/event/6402/
[#] http://connpass.com/event/6910/
[#] 'Farewell Node.js' https://medium.com/code-adventures/farewell-node-js-4ba9e7f3e52b
[#] http://socket.io/blog/introducing-socket-io-1-0/

Socket.IOについて
-----------------

しかしながら、双方向通信はいかなる場合もWebSocketが利用できるわけではありません。通信状況やクライアントの仕様によってはWebSocket以外の手段で通信が行われる場合もあるでしょう。そこでSocket.IOです。
Socket.IOを利用することで、双方向通信の確立方式、実装の違いを考えることなく、プログラマはアプリケーションの開発に集中することができます。その他、ルーム分割の機能や、認証機能、Redis等を利用してプロセス間の共有なども可能になっています。Socket.IOおよびEngine.IO（後述）は、双方向通信における様々の実装を隠蔽し、共通のインターフェースで開発ができるリアルタイムアプリケーション向けのライブラリ、と言うことができるでしょう。


Socket.IO10における主な変更点
----------------------------

5月末にリリースされた1.0ですが、次のような変更点があります。
* トランスポート層の実装をEngine.IOに移譲した
* バイナリデータの送信をサポートした
* ブラウザテストを自動化した
* スケーラビリティが向上した（よりシンプルになった）
* バックエンドでのSocket.IO連携が可能になった
* デバッグしやすくなった
* APIがよりシンプルになった
* CDN配信を提供することにした
上記変更点はブログ[#]_で言及されていますが、いくつか解説していきます。

トランスポート層の実装をEngine.IOに移譲した
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Engine.IOは、ざっくばらんに言うと「Websocketでもhttp pollingでも何でもいいからとにかく通信できる状態を確立する」ライブラリです。以前は通信に関する部分もSocket.IOが内包していましたが、1.0からはそれらの機能をEngine.IOに移譲し、Socket.IOはルーム機能や接続要求などの、より高度な機能のみ実装されるようになりました。実際、Socket.IO自体のコードはサーバ、クライアントそれぞれ1000行前後と大幅にシンプルになりました。また、Engine.IOは通信方式に関わらずWebSocktとして利用できるインターフェースを提供してくれるので、仮にWebSocktのみをサポートするのであれば、Engine.IOを利用せずともSocket.IOは動作するでしょう。
また、接続の確立方法がfallback形式からupgrade形式に変更になりました。
* 従来のfallback形式
 - WebSocktでの接続試行
  + 成功したら終了
 - 失敗した場合はタイムアウトを待つ（デフォルトは10秒）
 - その後http pollingで再試行する

* 新しいupgrade形式（ここで言うupgrade形式は、HTTP1.1におけるUpgradeとは異なるので注意してください）
 - http pollingでリクエストを行い、接続を確立する
 - 並列でUpgradeできるか判定する
  + 設定によりUpgradeせずに終了する
 - pollingしたままWebSocktでパケット通信できるか試行する
 - WebSocktでの通信に成功したら、メインのトランスポートを切替

WebSocktの接続が確立できないということはしばしば見られます。実際、ブラウザの問題というよりはプロキシやファイアウォールによってWebSocktの通信が阻まれることが多いです。これにより、従来のfallback形式だと接続確立までに大幅な時間を要することが問題でした。今回新たにupgrade方式を取ることによって、http pollingによる接続確立とWebSocktによる通信確立を並列で行うので、ユーザ体験を損なうことなく、タイムアウトして接続確立に時間がかかってしまう問題を解消しています。
一応、自分で通信プロトコルの選択したり再接続時の確立方式を選択できるオプションもあります。
.. transportsオプションやrememberUpgradeオプションに関するサンプルがあるとよさそう?

バイナリデータの送信をサポートした
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

現在のWebSocktはバイナリデータの送信をサポートしていますが、0.9までのSocket.IOではサポートされていませんでした。0.9以前のバージョンでバイナリデータを送信したいときは、お馴染みのbase64化をしてあげる必要があり、データ量としても実装としても、あまり効率のいいものとはいえませんでした。
1.0でついに対応され、プロトコルでは実装されているのにライブラリの制約で利用できないという冬の時代は終わりを迎えました。しかも、Socket.IOでのバイナリ送信はWebSocktによって定められたそれより使いやすくなっています。
WebSocktのバイナリフレームはBlobかArrayBuffer形式で送受信することが可能です。しかしながら、その他の形式には対応していなかったり、送信時にstring modeなのかbinary modeなのか明示する必要があったりと、非常に使い勝手が良い、とは言い難い部分もあります。Socket.IOはこれを解決しており、BufferやFileといったデータの送信もサポートしています。また、それを明示する必要もありません。複数のバイナリを同時に送受信することや、オブジェクトの中に埋め込んだりすることも可能です。
.. 0.9までのコード base64
.. WebSocktでのバイナリ送信
.. 1.0でのサンプル socket.emit('event', new Buffer([0, 1]); みたいな
あと、公式にバイナリ送信を検証するために作成されたポケモンのクローンやwindows XPのサンプルが面白いです。


スケーラビリティが向上した（よりシンプルになった）
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
middlewareとadapterの話

バックエンドでのSocket.IO連携が可能になった
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
socket.io event emitterの話

Socket.IO 0.x系から1.x系への移行時に気にしたいこと？
--------------------------------------------------------
apiがいくつか変更された点
認証やプロセス間データ共有がadapter経由になった
メモリリーク問題どうなった


