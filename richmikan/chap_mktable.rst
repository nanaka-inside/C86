表計算の章 ― JOINはjoinコマンドで
======================================================================

ショッピングカートに限らず、ビジネスに用いるソフトであれば
大抵避けられないのが表の結合(JOIN)という作業だ。
JOIN操作が必要であるがために、RDBにデータを格納して、
SQLに頼るという場合も多々ある。

しかし、UNIXにはもともともjoinという
そのまんまな名前のコマンドがあることを知らないのか!!
これがあれば、INNER JOINもOUTER JOINも自由自在。

**お前たちもっとUNIXをしゃぶり尽くせ** 、というのがこの章である。


この問題が解けるか?
----------------------------------------------------------------------

いきなりだが一つ問題を出してやる!

	問題:
	現在のプロセス一覧とそのプロセスの所有ユーザーの表を作れ。
	ただし、所有ユーザーはユーザー名ではなく、ユーザーID(番号)で示せ。

この問題、psコマンドがもちろん必要なのだが、それだけでは解けない。
psコマンドはプロセスに対応するユーザー名は表示できるが、
ユーザーID(番号)を機能を持ち合わせていないからだ。

解答はこうだ
``````````````````````````````````````````````````````````````````````

先に解答を載せてしまうぞ。(解説のため、一つにまとめられるであろうコマンドでも細かくステップ分けしているので悪しからず)

.. code-block:: bash
	:linenos:

	#! /bin/sh

	usermaster=$(mktemp /tmp/${0##*/}.XXXXXXXX)
	
	# === ユーザー名とユーザーIDの変換表として/etc/passwdを利用する ======
	cat /etc/passwd             |
	grep -v '^#'                | # コメント行を除去
	awk -F: '{print $1,$3}'     | # ユーザー名とユーザーIDの列だけ抽出
	# 1:ユーザー名 2:ユーザーID #
	sort -k1,1                  | # ソートを忘れずに!
	cat                         > $usermaster
	
	# === psコマンドの結果と先程のユーザーマスター表をJOINする ===========
	ps -Ao pid,user                         | # プロセスIDとユーザー名の表を出力
	tail -n +2                              | # ヘッダー行を削除
	# 1:プロセスID 2:ユーザー名             #
	sort -k2,2                              | # ユーザー名順にソート
	join -1 1 -2 2 -o 2.1,1.2 $usermaster -
	# 1:プロセスID(psコマンド由来) 2:ユーザー名(ユーザーマスター由来)
	
	rm -f $usermaster            # ユーザーマスター表ファイルを削除


/etc/passwdやpsコマンドの仕様はここでは説明せんが、ざっと説明しよう。

JOINは18行目でやっているのは見ての通り。
ここの引数の意味は、

* ユーザーマスターを左表に、psコマンド出力結果を右表に
* 左表1列目(ユーザー名)と、右表2列目(ユーザー名)を結合キーに
* 結合後は、右表1列目(プロセスID)、左表2列目(ユーザーID)の順で出力

である。ちなみにこれをSQL的に書いたとすればこうなる。

.. code-block:: sql
	:linenos:

	SELECT
	  PSCOMM.pid,
	  USRMST.uid
	FROM
	  ユーザーマスター表 AS USRMST
	    INNER JOIN
	  PSコマンド出力結果 AS PSCOMM
	    ON USRMST.uname = PSCOMM.uname;

両者が過不足無く対応していることがわかるだろう。

ソートをくれぐれも忘れぬこと
``````````````````````````````````````````````````````````````````````

ただし、joinコマンドを使う場合に気を付けなければならないことが1つある。
それはこのコマンドに与える左表も右表も、予め結合キーとする列でソートをかけなければならないといことだ。
なぜソートが必要なのかは、一度JOINという作業を紙に書いてやってみればよくわかる。

ソートが必要ということで、SQL文を利用するより不利に感じるかもしれないが
**SQL文でも内部的にはJOINの前にソートをやっている** 。
なので、その事を知らずに負荷を論じていたのであれば、笑われるから覚えておけよー!


応用すればOUTER JOINもできる
----------------------------------------------------------------------

joinコマンドというのは基本的にはINNER JOIN(内部結合)のためのものであり、
それ単体ではOUTER JOIN(外部結合)ができない。
しかし、sedと組み合わせ工夫すれば実現することができる。

例えば先程の解答コードにおいて、
何らかの事情でユーザーマスター表には自分とrootの行しかなかったとしよう。
擬似的には次のようにしてgrepの行を書き換えれば再現できる。

.. code-block:: bash
	:linenos:

	   :
	cat /etc/passwd             |
	grep -E '^(root|myuser):'   | # 自分とroot以外の行だけにする
	awk -F: '{print $1,$3}'     |
	# 1:ユーザー名 2:ユーザーID #
	sort -k1,1                  |
	cat                         > $usermaster

このように改造したうえで、先程の解答コードを動かすと、
INNER JOINなので、自分とroot以外が所有者のプロセスは全て非表示になる。

では、この場合でも他のユーザー番号にとりあえず ``*`` を生めるようにして、
OUTER JOINするにはどうすればよいか。

これも解答を先に書いてしまうぞ。


OUTER JOINをするために修正したコード
``````````````````````````````````````````````````````````````````````

.. code-block:: bash
	:linenos:

	#! /bin/sh

	usermaster=$(mktemp /tmp/${0##*/}.XXXXXXXX)
	
	# === ユーザー名とユーザーIDの変換表として/etc/passwdを利用する ======
	cat /etc/passwd             |
	grep -E '^(root|myuser):'   | # 自分とroot以外の行だけにする
	awk -F: '{print $1,$3}'     |
	# 1:ユーザー名 2:ユーザーID #
	sort -k1,1                  |
	cat                         > $usermaster
	
	# === psコマンドの結果と先程のユーザーマスター表をJOINする ===========
	ps -Ao pid,user                              |
	tail -n +2                                   |
	# 1:プロセスID 2:ユーザー名                  #
	sort -k2,2                                   |
	join -1 1 -2 2 -a 2 -o 2.1,1.2 $usermaster - | # -aオプションを追加する
	# 1:プロセスID(psコマンド由来) 2:ユーザー名(ユーザーマスター由来)
	sed 's/ $/ */'                                 # 左表2列目が空なら"*"を付ける
	
	rm -f $usermaster            # ユーザーマスター表ファイルを削除

変更点はまず、18行目のjoinに ``-a`` オプションを付けたことだ。
このオプションがあると、結合キー名が一致しなかった場合でもその後に指定した表の
列は出力されるようになる。このコードでは ``-a 2`` としているので
右表(psコマンドの出力)が出てくる。

もう一つの変更点は、20行目にsedコマンドを追加したことだ。
joinの出力は、右表1列目、左表2列目と指定しているが、
結合キーが一致せずに出力された行は左表2列目が欠けている。
列の区切りは半角スペースだから、従って行末は半角スペースで終わっているはずだ。
そこで、そのような行末を見つけたら"*"を追記する、という処理を追加しているのだ。

この例では空になる列が行末に1つだけだったが、
もし空(ヌル)列が複数がある場合や、行末に限らない場合は、次のように一般化できる。

.. code-block:: bash

	join (ここで何らかのOUTER JOINをする) |
	sed 's/ $/ */'                        |
	sed 's/^ /* /'                        |
	sed 's/  / * /g'                      |
	sed 's/  / * /g'

スペースが2つ連続する箇所があれば、それは空(ヌル)列があることを示唆しているので
それを取り除くためにこのようなことを行っている。

SQLでできることはほぼ全てできる
----------------------------------------------------------------------

このようにして、JOIN操作はSQLを使わなくてもjoinコマンドでできることを示したわけだが、
SQLで登場する他の句もほぼコマンドで置き換えることが可能だ。
例えば、ORDER BYをやりたければ、最後にもう一度sortコマンドをパイプで繋げばよいし、
WHERE句はAWKやgrepコマンド、UNIONはcatで複数の結果を繋げばいい、という具合だ。

ほんの一部を表にまとめておこう。

.. table:: SQL文とUNIXコマンドの対応 [#ast_is_tukubai]_

   +---------------------+----------------------------------------+
   | SQLの句             | 相当するコマンド                       |
   +=====================+========================================+
   | SELECT句の列指定    | AWK、self `*`:sup: コマンドなど        |
   +---------------------+----------------------------------------+
   | FROM句              | 各コマンドでのファイル指定             |
   +---------------------+----------------------------------------+
   | WHERE,HAVING句      | AWK、grepなど                          |
   +---------------------+----------------------------------------+
   | ORDER BY            | sortコマンド                           |
   +---------------------+----------------------------------------+
   | INNER JOIN          | sort+joinコマンド                      |
   +---------------------+----------------------------------------+
   | OUTER JOIN          | sort+join+sedコマンド                  |
   +---------------------+----------------------------------------+
   | UNION               | catコマンドで結果を繋げる              |
   +---------------------+----------------------------------------+
   | GROUP BY+sum        | sm2 `*`:sup: コマンドなど              |
   +---------------------+----------------------------------------+
   | 副問い合わせ        | 結果をパイプやファイルでコマンドに繋ぐ |
   +---------------------+----------------------------------------+

.. rubric:: 脚注

.. [#ast_is_tukubai] "*"を付けたコマンドは、Open usp Tukubaiで提供されているコマンド。


シェルショッカー1号での実例
----------------------------------------------------------------------

JOINというのは基本的な操作であり、シェルショッカー1号においても
色々なところで行っているが、INNER JOINもOUTER JOINも両方行っている実例が
CGI/SHOWQTYS.AJAX.CGIの中にある。
これは、問い合わせを受けた商品IDの在庫数をJSONで答えるAjax型の
CGIスクリプトだ。

INNER JOINの例(CGI/SHOWQTYS.AJAX.CGI内、244行目付近)
``````````````````````````````````````````````````````````````````````

.. code-block:: bash

	# 2)メッセージ作成
	msg=$(cat $Tmp-curqtytbl                                 |
	      # 1:商品ID* 2:現在庫数                             #
	      awk '$3~/^[0-9]+$/'                                | # 電子商品在庫無限なので除外
	      awk '$2>$3'                                        | # 超過商品だけ抽出
	      join -1 -2 1 -o 2.1,1.2,2.2,2.3 $Tmp-productname - |
	      # 1:商品ID* 2:商品名(mojihameエスケープ) 3:現在カゴ入れ数 4:現在庫数(無限の場合は"*")
	      self 2                                             |
	      sed 's/\\_/'$ACK'/g'                               | # 商品名を横に並べる
	      tr _ ' '                                           | #  :
	      sed 's/\\\(.\)/\1/g'                               | #  :
	      tr $ACK '_'                                        | #  :
	      tr '\n' "$ACK"                                     | #  :
	      sed 's/'"$ACK"'$//'                                | #  :
	      sed 's/'"$ACK"'/, /g'                              ) #  :
	[ -n "$msg" ] && msg='申し訳ありません。次の商品の在庫数がご要望の数量を下回りました。\\n('"$msg"')'

これは、リクエストされた商品のうちでリクエスト数量が現在在庫数を上回っているものがないか
調べる部分のコードだ。
冒頭では、商品は商品IDで管理しているが、
メッセージを出力する段階になったらこれを商品名に置換する必要があるので
商品マスター表とINNER JOINして商品名をレコードに追加するというわけだ。


OUTER JOINの例(CGI/SHOWQTYS.AJAX.CGI内、264行目付近)
``````````````````````````````````````````````````````````````````````

.. code-block:: bash

	# 2)カゴ入れ商品情報行のカゴ入れ数を、超過数を考慮して更新
	zcat "$File_session"                                    |
	grep '^[A-Za-z0-9_.-]\+[[:blank:]]\+[0-9]\+$'           |
	join -1 1 -2 1 -a 2 -o 2.1,1.2,1.3,2.2 $Tmp-curqtytbl - |
	sed 's/  / * /'                                         |
	sed 's/  / * /'                                         |
	# 1:商品ID 2:現在カゴ入れ数(こちらではなく4を使うこと) 3:現在庫数(無限orに表に無い場合は"*") 4:現在カゴ入れ数
	awk '$3~/^[0-9]+$/ && $3<$4{$4=$3} $4>0{print $1,$4}'   >> $Tmp-newsessionfile

こっちはOUTER JOINの実例だ。
買い物カゴファイル(File_session)の中に入っている商品数が、
万が一現在の店の在庫数を上回っていたら在庫数まで値を減らすということをやっている。

店の在庫数をマスター表としているのだが、電子商品については在庫を持たないのでマスター表には存在しない。
なので、普通にINNER JOINしてしまうと電子商品がカゴから消えてしまう。
これを防ぐためにOUTER JOINを行っているのだ。

joinの ``-o`` オプションを見るとわかるように、空(ヌル)列が途中に複数個並ぶ可能性があるので、
同じ置換パターンのsedを2回通している。
