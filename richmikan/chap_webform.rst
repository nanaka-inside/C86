入力フォームの章 ― sedとmojihameでフォーム作成
======================================================================

ショッピングカートプログラムの中で量が多くて手間なのが、
顧客情報入力フォームの処理だ。

入力されたデータの正当性を1つ1つ確認しなければならないし、
また、再入力を促す場合など、現時点の入力値を<input>タグ<select>タグなどに
ハメ込まなければならない。

正当性確認はgrepの正規表現等を使って一つ一つ確認する他無いが、
HTML上に値をハメ込むのは簡単にできるように、独自コマンドが用意されている。


単純なマクロ文字置換も意外と大変
----------------------------------------------------------------------

例えば、次のようなHTMLテンプレートがあったとする。

.. code-block:: html

	苗字:<input type="text" name="name" value="###NAME###" /><br />
	備考欄:<br />
	<textarea name="biko">###BIKO###</textarea>


この中の ``###NAME###`` や、 ``###BIKO###`` の部分に文字をハメるのは意外と苦労するのだ。
なぜなら、

* sedコマンドに反応する文字(正規表現メタ文字やスラッシュ)はエスケープしなければならない。
* ダブルクォーテーションに囲まれている文字列は、ダブルクォーテーションをエスケープしなければならない。
* <textarea>に囲まれている文字列は、タグ記号( ``<`` や ``>`` )をエスケープしなければならない。
* HTMLでエスケープ対象の文字 ``&`` もエスケープしなければならない。

などなど、誤動作を防ぐために様々な注意が必要だ。
時には悪意を持ったユーザーが誤動作を誘う文字を仕込んでくる場合だってあり得る。
シェルショッカーの掟では、そんなコードを書こうものなら ``rm -rf`` されることになるので気を付けねばならん。

せめて正規表現メタキャラだけでもどーにかならんか
``````````````````````````````````````````````````````````````````````

特に正規表現のメタキャラをエスケープするのが煩わしい。
そこで我々は、独自のコマンド ``fsed`` というものを作った。
イメージとしては、grepコマンドに対してfgrepというメタキャラの反応しないgrepがあるように、
メタキャラに反応しないsedというわけだ。

シェルショッカー1号のディレクトリーでは、UTL/fsedとして収録してあるが、
ちょっと中身を覗いてみるとこんな感じになっている。

.. code-block:: bash
	:linenos:

	#! /bin/sh
	pat=$(printf '%s' "$1"            |
	      sed 's/\([].\*/[]\)/\\\1/g' |
	      sed 's/^\^/\\^/'            |
	      sed 's/\$$/\\$/'            )
	sub=$(printf '%s' "$2"         |
	      sed 's/\([\&/]\)/\\\1/g' )
	sed "s/$pat/$sub/g" "$3"


本番のsed(8行目)に掛ける前に、置換されるパターン文字列と置換する文字列をそれぞれsedに掛け、
誤動作を引き起こす文字をエスケープしている。

こうすることで、

.. code-block:: bash

	#! /bin/sh
	
	cat template.html                       |
	fsed ###NAME### 'シェル/ショッカー'     |
	fsed ###BIKO### 'Q&Aを掲載してください'

などのように、sedを誤動作させる ``/`` や ``&`` などの文字が安全に通せる。


mojihameコマンドで、明細HTMLが簡単に作れる
----------------------------------------------------------------------

Open usp Tukubaiにあるコマンドの一つにmojihameというがあるのだが、
これは数あるコマンドの中でも偉大な発明品だと思う。
なにせ、これがあれば顧客向けた購入商品の明細表生成が簡単にできるのだ。

.. code-block:: text

	# 商品名                       単価  数量     小計
	シェルショッカーの掟_(単行本) 1,200     1    1,200
	シェルショッカーステッカー      200     3      600
	送料                            164     1      164
	合計                             -      -    1,964

なーんていう、明細テキスト(meisai.txt)があったとする。
これに基づいて明細表のHTMLを生成したいとする。
そんな時は、次のようなHTMLテンプレート(template.html)を用意して……

.. code-block:: html

	<table>
	  <tr>
	    <th>商品名</th><th>単価</th><th>数量</th><th>小計</th>
	  </tr>
	  <!-- ITEMS -->
	  <tr>
	    <td>%1</td><td>%2</td><td>%3</td><td>%4</td>
	  </tr>
	  <!-- ITEMS -->
	</table>

次のようなmojihameコマンドを叩くと、

.. code-block:: bash

	$ cat meisai.txt | mojihame -l ITEMS template.html

こういう結果が出力される。

.. code-block:: html

	<table>
	  <tr>
	    <th>商品名</th><th>単価</th><th>数量</th><th>小計</th>
	  </tr>
	  <tr>
	    <td>シェルショッカーの掟 (単行本)</td><td>1,200</td><td>1</td><td>1,200</td>
	  </tr>
	  <tr>
	    <td>シェルショッカーステッカー</td><td>200</td><td>3</td><td>600</td>
	  </tr>
	  <tr>
	    <td>送料</td><td>164</td><td>1</td><td>164</td>
	  </tr>
	  <tr>
	    <td>合計</td><td>-</td><td>-</td><td>1,964</td>
	  </tr>
	</table>

HTMLテンプレートの中の ``ITEMS`` で囲まれた区間が、明細テキストの行数分だけ複製され、
``%n`` で指定されたマクロ文字部分に各列の文字列がハメ込まれる。

forやwhileループを使わずに<tr>～</tr>がレコードの数だけ生成されるので、
シェルスクリプトも見やすい。これはものすごく便利だ。
あまりに便利なので、HTML以外にも次章で話すメール本文に貼り付ける明細にも利用している。

ちなみにこの例よーく見ると、明細テキストにあった「シェルショッカーの掟_(単行本)」という文字列の
アンダースコア( ``_`` )が、半角スペースに変化している。
これは半角スペースをハメ込めるようにするためのエスケープだ。
ちなみにアンダースコア自身をハメ込みたければ ``\_`` と書き、
バックスラッシュを書き込みたい場合は ``\\`` と書く。

シェルショッカー1号での実例
----------------------------------------------------------------------

fsedコマンドもmojihameコマンドも、
シェルショッカー1号の中のあちこちのシェルスクリプトで出てくるが、
その中でも顧客情報入力を担当するCGI/CASHIER.CGIを見ると、特に頻出する。

ここではmojihameコマンドの実例を見せてやる。

CGI/CASHIER.CGI内、937行目付近)
``````````````````````````````````````````````````````````````````````

.. code-block:: bash

	   :
	# --- レシートデータをHTMLテンプレ(テーブル区間)にmojihame -----------
	# 1)元のHTMLテンプレからテーブル区間を抽出
	cat "$Dir_HTMLTMPL/${0##*/}.CONFIRM.HTML" |
	sed -n '/RECEIPT_HTML/,/RECEIPT_HTML/p'   > $Tmp-htmltmpl-tablepart
	# 2)商品行をmojihame
	cat $Tmp-receipt                                          |
	grep -v '^\(TAX\|POSTAGE\|TOTAL\)[[:blank:]]'             |
	sed 's/\\\\/'"$ACK"'/g'                                   | # 商品名列内の\をエスケープ
	mojihame -lHTML_TABLE_PARTS_ITEMS $Tmp-htmltmpl-tablepart |
	tr "$ACK" '\\'                                            > $Tmp-tablepart1
	   :

これは、顧客情報が全て正しく入力されていた場合に、
「この内容で間違いありませんか?」という確認画面作成ルーチンの中で、
注文内容の表を生成している部分だ。

ただこれだけ見てもよくわからんだろうから次に掲載するHTMLテンプレートも見るがいい。

TEMPLATE.HTML/CASHIER.CGI.CONFIRM.HTML内、302行目付近)
``````````````````````````````````````````````````````````````````````

.. code-block:: html

	    :
	  <!-- RECEIPT_HTML -->
	  <tr>
	    <th>商品名/価格</th>
	    <th>数量</th>
	    <th>小計</th>
	  </tr>
	  <!-- HTML_TABLE_PARTS_ITEMS -->
	  <tr>
	    <td class="item_name_price_area"><span class="item_name"    >%2</span><br /><span class="item_price">%3円</span></td>
	    <td class="item_qty_area"       >%4</td>
	    <td class="item_total_area"     ><span class="item_subtotal">%5円</span></td>
	  </tr>
	  <!-- HTML_TABLE_PARTS_ITEMS -->
	  <!-- HTML_TABLE_PARTS_TAX -->
	  <tr>
	    :

``HTML_TABLE_PARTS_ITEMS`` の区間がmojihameコマンドによって繰り返される。
割愛しているが、実際の例では、各商品行と消費税行、送料行、合計行は、個別にmojihameコマンドを適用している。
